\subsection{Shifumi}
    Une stratégie simple et efficace à laquelle on pourrait penser pour gagner
    au Shifumi serait de jouer de manière aléatoire.

    Et en effet, il s'avère que si les deux joueurs jouent de manière équiprobable,
    on a affaire à un équilibre de Nash~: aucun changement de stratégie de la part
    d'un joueur ne pourra lui permettre d'augmenter ses chances de gagner.
    %todo: expliquer plus Nash

    De plus, si un adversaire ne joue pas de manière aléatoire (ou augmente la
    probabilité de jouer un certain élément), alors on pourra prévoir ce qu'il
    va jouer et donc trouver une stratégie qui pourra le battre. Les humains
    étant très mauvais pour jouer de manière aléatoire, il est assez facile
    d'écrire une stratégie permettant de les battre.

  \subsubsection{Chaines de Markov}
    Une autre stratégie se base sur des chaînes de Markov: en se basant sur les
    derniers éléments joués, elle regarde dans l'historique pour voir l'élément
    qui était joué le plus souvent par l'adversaire après les derniers coups
    joués.

    Cette stratégie s'avère vraiment efficace contre un joueur humain.
    Toutefois, elle est prévisible: si on sait qu'on a affaire à une telle
    stratégie, on peut jouer de manière à la battre.

    C'est pour cela qu'une stratégie aléatoire est la seule pouvant maximiser
    nos gains dans le pire des cas.

  \subsubsection{Variantes}
    Toutes les variantes du Shifumi qui consistent à rajouter des éléments
    pour obtenir un nombre d'éléments pair (par exemple
    pierre/papier/ciseaux/puits) vont créer un déséquilibre, car un élément
    sera moins efficace contre les autres. L'équilibre de Nash du jeu va
    alors consister à ne jamais jouer cet élément.

    Si le nombre d'éléments est impair, alors le jeu pourra être équilibré,
    comme un Shifumi classique.

\subsection{Jeu de la somme magique}
  Ce jeu consiste à choisir, à tour de rôle, $n$ nombres parmi $n^2$ afin que
  leur somme soit égale à $\frac{n(n^2+1)}{2}$.

  \subsubsection{Représentation sous forme de morpion}
Une représentation possible de ce jeu est le carré magique: les
joueurs doivent choisir, l'un après l'autre une case dans un carré
magique, leur but étant de contrôler une ligne, une colonne ou une
diagonale entière du carré magique; alors, les nombres qu'ils auront
choisis totaliseront le score voulu. De même, ce problème correspond exactement
au jeu du morpion, étendu à des grilles $n \times n$.

Ainsi, une des stratégies possibles pour un joueur du jeu de la somme
magique est de construire un carré magique, et de représenter les
nombres choisis par l'adversaire par un rond dans la case
correspondante. Afin de choisir un nombre, il suffit d'appliquer la
stratégie de morpion de son choix sur le carré magique, et de
jouer le nombre correspondant.

Le choix du carré magique n'importe pas. En effet, dans un carré
magique sont présentes toutes les possibilités de combinaison de
nombres pour obtenir la somme voulue. Par conséquent, peu importe le
carré magique d'ordre $n$ que l'on choisit, les représentations sous forme de
morpion seront toutes équivalentes.

Le morpion étant un jeu où l'on essaie de minimiser la perte maximum,
on peut s'intéresser à l'algorithme du minmax, pour déterminer une
stratégie non perdante.

\subsubsection{Algorithme du minmax appliqué au jeu du morpion}
L'algorithme du minmax consiste à évaluer toutes les positions de jeu
atteignables depuis la position courante, sur une certaine profondeur
(autrement dit, un certain nombre de tours de jeu), et à jouer de
manière à atteindre la position la plus avantageuse, en supposant que
l'adversaire joue toujours le meilleur coup pour lui-même (ce coup
étant évalué avec notre propre fonction d'évaluation, qui n'est pas
forcément la même que celle de l'adversaire).

Par conséquent, afin d'implémenter l'algorithme du minmax, il faut
commencer par déterminer une fonction d'évaluation.

\paragraph{Fonction d'évaluation}
La fonction d'évaluation que nous avons choisie est très simple: une
ligne, colonne ou diagonale (que nous appelleront désormais simplement
``ligne'') complétée avec notre symbole (ce qui signifie qu'on a
gagné) vaut $+\infty$; si, au contraire, l'adversaire a complété une
ligne, alors cette ligne vaut $-\infty$. Une ligne contenant
uniquement notre symbole rapporte le nombre d'occurrences de notre
symbole dans cette ligne ; à l'inverse, une ligne contenant uniquement
le symbole de l'adversaire rapportera négativement le nombre
Toutes les autres lignes ne rapportent aucun point.
Ainsi, l'évaluation d'une position de jeu est la somme des points
rapportés par chacune de ses lignes, colonnes et diagonales.

\paragraph{Minmax}
L'algorithme du minmax va construire (implicitement) l'arbre des coups
possibles à partir de la position courante.
L'évaluation d'un nœud de cet arbre sera:
\begin{itemize}
  \item si c'est à notre tour de jouer, le maximum de l'évaluation de nos fils;
  \item si c'est à l'adversaire de jouer, le minimum de l'évaluation
    de ses fils (i.e.\ on suppose que l'adversaire joue le meilleur
    coup à sa disposition, selon la fonction d'évaluation du joueur courant).
\end{itemize}

L'évaluation d'une feuille de l'arbre se fera par la fonction
d'évaluation définie précédemment.

Ainsi, l'algorithme se dirigera naturellement vers la position la plus
avantageuse pour lui.

\subsubsection{Élagage alpha-bêta}
L'élagage alpha-bêta permet de réduire le nombre de nœuds à parcourir durant
l'algorithme du minmax.

Cet algorithme arrête le parcours des fils d'un nœud quand il se rend
compte qu'il ne pourra pas faire mieux.

Dans l'exemple suivant, où les nœuds en bleus sont ceux où l'on doit prendre
le minimum, et ceux en gris le maximum:
\begin{multicols}{2}\begin{center}
  \begin{tikzpicture}[node distance=1.3cm,bend angle=45,auto]
    \node[draw, rectangle, gray] (U) {U};
    \node[draw, circle, blue] (5) [below left=of U] {5};
    \node[draw, circle, blue] (V) [below right=of U] {V};
    \node[draw, rectangle, gray] (4) [below left=of V] {4};
    \node (dots) [below right=of V] {\ldots};

    \path (U) edge node {} (5);
    \path (U) edge node {} (V);
    \path (V) edge node {} (4);
    \path (V) edge node {} (dots);
  \end{tikzpicture}

  Coupure Alpha

  \begin{tikzpicture}[node distance=1.3cm,bend angle=45,auto]
    \node[draw, circle, blue] (U) {U};
    \node[draw, rectangle, gray] (5) [below left=of U] {5};
    \node[draw, rectangle, gray] (V) [below right=of U] {V};
    \node[draw, circle, blue] (4) [below left=of V] {4};
    \node (dots) [below right=of V] {\ldots};

    \path (U) edge node {} (5);
    \path (U) edge node {} (V);
    \path (V) edge node {} (4);
    \path (V) edge node {} (dots);
  \end{tikzpicture}

  Coupure Béta
\end{center}\end{multicols}

On se rend bien compte qu'on n'a pas besoin de parcourir les nœuds suivant,
car on prend le maximum des minimums, ou l'inverse.

Par exemple, pour la coupure alpha: si on trouve des fils de $V$ plus petit
que $4$, on va prendre le maximum, donc c'est $4$ qui sera utilisé, et si on
trouve plus grand ou égal à $5$, on devra prendre le minimum au niveau de $V$,
donc on prendra $5$ dans tous les cas.

Au final, cette amélioration permet de gagner un temps considérable pour
obtenir le même résultat.
