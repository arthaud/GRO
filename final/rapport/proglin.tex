\subsection{Introduction}
  La programmation linéaire, ou optimisation linéaire, consiste à maximiser (ou
  de manière équivalente minimiser) une fonction linéaire sur un polyèdre
  convexe (dont un cas particulier courant est sous des contraintes linéaires).

\subsection{Problème du sac à dos}
  \subsubsection{Présentation du problème}
    Ce problème paraît simple en apparence: nous avons un ensemble d'objets,
    chaque objet pouvant avoir une masse différente et ayant une certaine
    valeur, et nous voulons remplir un sac à dos de manière à maximiser la
    valeur totale, sans dépasser une certaine masse maximale.

    Résoudre ce genre de problème est utile par exemple en gestion de
    portefeuilles pour trouver le meilleur rapport entre rendement et risque,
    ou en découpe de matériaux, pour minimiser les chutes.

    \paragraph{}
    Ce problème est un problème d'optimisation linéaire, en effet, cela revient
    à résoudre le problème:
    \[ \begin{array}{r|l}
        \displaystyle\max_{i \in S' \subset S} v_i &
        \displaystyle\sum_{i \in S'} m_i \leq W
      \end{array}
    \]
    où $S$ est l'ensemble des objets, $S'$ est un ensemble de $n$ objets
    choisis, $v_i$ la valeur de l'objet $i \in S$, $m_i$ sa masse et $W$ la
    masse maximale autorisée dans le sac.

    Cependant la résolution de ce problème n'est pas simple: déterminer s'il
    est possible de dépasser une valeur minimale sans dépasser le poids maximal
    est un problème NP\nobreakdash-complet.

  \subsubsection{Résolution exacte}
    Une exploration exhaustive de l'ensemble des parties de $S$ n'est pas très
    réaliste, car celui-ci est de cardinal $2^{\mathrm{card} S}$.

    Mais, ce problème peut être résolu en utilisant la programmation
    dynamique\footnote{Qui consiste à résoudre un problème de taille $n$ à
    partir de la résolution d'un problème de taille $n-1$}. En effet, on peut
    déterminer si un objet $i$ fait parti de l'ensemble des objets à choisir en
    considérant le problème sur l'ensemble $S\backslash\{i\}$ et la masse
    maximale $W-m_i$.
    
    Toutefois, un tel algorithme (voir algorithme~\ref{alg:sacados}) fonctionne
    uniquement si les poids des objets
    sont des entiers. De plus sa complexité en temps est en $O(nW)$ et celle en
    mémoire en $O(W)$\footnote{En pratique on pourrait l'utiliser sur des
    masses non-entières en les multipliant, ce qui augmenterait la complexité
    du même facteur. De plus on peut réduire la complexité temporelle en
    $O(nW')$ avec $W' = \frac W {\mathrm{ppcm}(\text{toutes les masses})}$.}.

    \begin{algorithm}
      \KwIn{une liste d'objets}
      \KwIn{une masse maximale autorisée}
      \KwOut{la valeur maximale qu'il est possible d'atteindre}
      \Begin{%
        ligne\_courante = liste composée de (masse\_max+1) zéros\;
        ligne\_prec     = liste composée de (masse\_max+1) zéros\;
        \For{chaque objet obj de la liste d'entrée}{%
          \For{m variant de 0 à masse\_max}{%
            \If{masse(obj) $\leq$ m}{%
              ligne\_courante[m] $\leftarrow$ max(ligne\_prec[m], ligne\_prec\_line[m-masse(obj)] + prix(obj))\;
            }
          }
          ligne\_prec $\leftarrow$ ligne\_courante
        }
        \Return{ligne\_courante[masse\_max]}
      }
      \caption{Algorithme de résolution exacte du problème du sac à dos}
      \label{alg:sacados}
    \end{algorithm}

  \subsubsection{Résolution approchée}
    Un autre algorithme pour résoudre ce problème, dit algorithme glouton,
    consiste simplement à choisir les «~meilleurs~» objets jusqu'à que la masse
    maximale soit dépassée. Le critère déterminant quels sont les meilleurs
    objets pourrait être la masse faible, le prix élevé, ou le rapport
    prix/masse élevé.

    Cet algorithme est beaucoup plus rapide que le précédent (il a une
    complexité en temps de $O(n \log n)$ (pour le tri des objets)) et ne
    nécessite en mémoire que la liste des objets, mais ce n'est qu'un algorithme
    approché. Les résultats obtenus sont cependant très satisfaisant, en effet
    en considérant le ratio \nobreak prix/masse, on obtient des résultats très
    proches de l'optimum (quelques pourcents d'erreur relative en moyenne, mais
    aucune garantie n'est fournie: il peut même fournir la pire solution).

    De plus il peut être utilisé quand les masses ne sont pas entières.

    \paragraph{}
    Un autre algorithme pour résoudre ce problème est inspiré du comportement
    des fourmis: une ``fourmi'' se promène plus ou moins au hasard dans
    l'ensemble des possibilités en marquant les objets choisis comme
    intéressants (comme les fourmis le font avec les phéromones). Ces fourmis
    vont essayer de choisir de plus en plus souvent les objets ayant souvent
    été marqués intéressants. On s'arrête après un certain nombre de tours ou
    quand les nouvelles itérations ne sont plus considérés suffisamment
    intéressantes.

\subsection{Problème du simplexe}
  \todo
