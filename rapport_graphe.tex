\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}

\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\newcommand{\brokencell}[2][c]{\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\lstset{frame=single, breaklines=true,
          breakatwhitespace=true, basicstyle=\scriptsize,
          showstringspaces=false, escapeinside={(*}{*)},
          keywordstyle=\color{deepblue},
          stringstyle=\color{deepred},
          commentstyle=\color{deepgreen},
          literate=
                   {é}{{\'e}}1{É}{{\'E}}1
                   {è}{{\`e}}1{È}{{\`E}}1
                   {ê}{{\^e}}1{Ê}{{\^E}}1
                   {à}{{\`a}}1{À}{{\`A}}1
                   {ù}{{\`u}}1{Ù}{{\`U}}1
                   {û}{{\^u}}1{Û}{{\^U}}1
                   {ô}{{\^o}}1{Ô}{{\^O}}1
                   {ó}{{\'o}}1{Ó}{{\'O}}1
                   {ç}{{\c c}}1{Ç}{{\c C}}1
                   {œ}{{\oe}}1{Œ}{{\OE}}1
        }

\begin{document}
\title{Rapport du projet de théorie des graphes}
\author{Maxence Ahlouche \and Maxime Arthaud \and Korantin Auguste
          \and Martin Carton \and Thomas Forgione \and Thomas Wagner}
\date{7 octobre 2013}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Présentation de l'équipe}
  Cette équipe a été menée par Korantin Auguste, assisté de son Responsable
  Qualité Martin Carton. Les autres membres de l'équipe sont Thomas Wagner,
  Thomas Forgione, Maxime Arthaud, et Maxence Ahlouche.
  
  Tous les membres de l'équipe ont été présents à chacune des séances lors de
  cette UA.

\section{Modélisation mathématique}
  Nous avons choisi de représenter nos graphes comme une liste de sommets,
  chacun ayant une liste d'arêtes.
  % todo blabla

  Dans la suite nous noterons $n$ le nombre de sommets du graphe.

\section{Graphes eulériens}
  \subsection{Analyse mathématique}
    Un graphe eulérien est un graphe contenant un cycle eulérien, c'est-à-dire
    un chemin parcourant toutes les arêtes du graphe une et une seule fois, en
    revenant au sommet de départ; ce problème est donc celui de la goudronneuse
    qui doit passer sur toutes les rues sans pouvoir repasser dessus une
    seconde fois. Un théorème fondamental garantit qu'un graphe connexe est
    eulérien si et seulement si chacun de ses sommets est associé à un nombre
    pair d'arêtes.

    Un graphe semi-eulérien, quant à lui, contient une chaîne eulérienne:
    celle-ci passe également par toutes les arêtes du graphe une seule et
    unique fois, mais ne retourne pas au point de départ. Le théorème précédent
    se généralise alors aux graphes semi-eulériens: un graphe connexe et
    semi-eulérien si et seulement tous ses sommets sauf deux sont associés à un
    nombre pair d'arêtes. Dans ce cas, la chaîne eulérienne aura pour départ
    l'un des deux sommets associés à un nombre impair d'arêtes et pour point
    d'arrivée le deuxième.

  \subsection{Méthode de résolution}
    Afin de trouver une chaîne ou un cycle eulérien dans un graphe, nous avons
    implémenté deux méthodes: une méthode qui teste toutes les possibilités,
    et une autre plus intelligente et moins coûteuse.

    \subsubsection{Matrices latines}
      La première méthode est inspirée des matrices latines. Chaque coefficient
      de la matrice sera un ensemble de chemins, un chemin étant lui-même une
      liste de sommets. La matrice latine de notre graphe sera la matrice $M$
      dont chaque coefficient $m_{i,j}$ vaudra:
      \begin{itemize}
        \item l'ensemble vide si le nœud $i$ n'est pas relié au nœud $j$ dans
          le graphe;
        \item un ensemble contenant pour unique élément le chemin $[N_i,N_j]$
          si les nœuds $i$ et $j$ sont reliés (où $N_k$ représente le nœud
          $k$).
      \end{itemize}

      Nous définissions ensuite un produit sur les coefficients d'une telle
      matrice. Le produit de deux chemins sera:
      \begin{itemize}
        \item nul si le dernier nœud du premier chemin n'est pas le premier
          nœud du deuxième;
        \item la concaténation des deux chemins sinon.
      \end{itemize}

      Le produit de deux ensembles de chemins sera l'ensemble contenant les
      produits de chaque couple de nœuds.

      Pour tout $k$ entier naturel, le coefficient $(i,j)$ de la matrice $M^k$
      représentera l'ensemble des chemins de longueur $k$ reliant les nœuds $i$
      et $j$.
      
      Puisque un chemin eulérien passe une unique fois par chaque arête, il
      suffira de calculer la matrice latine élevée à cette puissance pour
      trouver sur sa diagonale l'ensemble des cycles possibles. En éliminant à
      chaque produit les chemins qui passent plusieurs fois par la même arête,
      on trouve l'ensemble des cycles eulériens.

	  La complexité de cette algorithme est exponentielle, calculer la puissance
	  de la matrice latine revient en fait à calculer chaque chemin possible dans
	  le graphe, et tester s'il est un cycle eulérien ou non.
	
    \subsubsection{Algorithme d'Euler}
      La deuxième méthode, basée sur l'algorithme d'Euler est nettement plus
      efficace. Une fonction récursive cherche un cycle eulérien d'un
      sous-graphe de notre graphe de départ, puis s'appelle récursivement sur
      chacun des sommets parcourus par ce chemin, dans le graphe où l'on a
      supprimé les arêtes déjà parcourues. En reconstruisant ces cycles
      astucieusement, on parvient à trouve un cycle eulérien de complexité
      linéaire en le nombre d'arêtes du graphe. 

  \subsection{Algorithmes}
    \subsubsection{Méthode de la matrice latine}
      \begin{lstlisting}
Entrée : un graphe
Sortie : la liste des cycles eulériens dans le cas d'un graphe eulérien
         la liste des chemins eulériens dans le cas d'un graphe semi-eulérien
         la liste vide sinon

Construire la matrice latine du graphe :
    construire une matrice à n lignes et n colonnes
    remplir la matrice de listes vides
    pour chaque nœud du graphe:
        pour chaque arête sortant de ce nœud:
            ajouter la liste [noeud de départ, noeud d'arrivée] à la case de la matrice correspondante

n = "le nombre d'arêtes total du graphe"

calculer la puissance (n-1)ième de la matrice

pour chaque coefficient de la matrice ainsi calculée:
    si le coefficient n'est pas nul:
        concaténer ce coefficient à la variable de retour
      \end{lstlisting}

    \subsubsection{Produit matriciel}
      \begin{lstlisting}
Entrée : A et B deux matrices latines
Sortie : le produit de ces deux matrices

construire la matrice de retour à n lignes et n colonnes
initialiser chaque coefficient de cette matrice à la liste vide

pour chaque coefficient de la matrice de retour:
    pour k allant de 1 jusqu'à n:
        calculer les chemins produits entre a(i,k) et b(k,j)
        ajouter au coefficient de la matrice ces chemins
      \end{lstlisting}

    \subsubsection{Produit entre listes de chemins (coefficients de matrices
    latines)}
      \begin{lstlisting}
Entrée : liste_1 et liste_2 deux listes de chemins
Sortie : une liste de chemins

créer une liste de chemins vide (liste de retour)
pour i dans liste_1:
    pour j dans liste_2:
        construire le chemin résultant de la concaténation de i et j (en enlevant le nœud présent deux fois)
        construire un ensemble de chemins vide
        pour k allant de 1 à la longueur du chemin construit:
            construire le chemin élémentaire menant du nœud k au nœud k+1
            si ce chemin n'est pas dans l'ensemble:
                ajouter ce chemin dans l'ensemble
            sinon:
                rendre le chemin nul
                sortir de la boucle

        si le chemin n'est pas nul:
                concaténer le chemin trouvé à la liste de retour
retourner la liste de retour
			\end{lstlisting}



\section{Graphes hamiltonien}
  \subsection{Analyse mathématique}
    Un graphe (semi-)hamiltonien est un graphe sur lequel on peut
    trouver un cycle(/chemin) passant par tout les sommets une et une seule
    fois. Ce problème est donc celui de l'enfant qui souhaite visiter de
    manière unique toutes les salles d'un musée.

    Le problème de savoir si un graphe est (semi-)hamiltonien est NP-complet,
    de même que de trouver un cycle ou chemin s'il y en a.

    Il existe cependant des conditions suffisantes pour lesquelles on peut
    affirmer qu'un graphe est hamiltonien ou non.

    Par exemple un graphe complet est forcement hamiltonien (utile dans le cas
    du voyageur de commerce, voir section~\ref{sec:tsp}), il existe aussi des
    conditions sur les degrès des sommets (théorème de Dirac, d'Ore, etc.).

  \subsection{Méthode de résolution}
    Pour tester si un graphe est hamiltonien, nous avons utilisé les théorèmes
    de Dirac et Pósa qui donnent des conditions nécessaires, si ces conditions
    ne sont pas vérifiées, comme il n'y a aucun théorème qui permette
    d'affirmer qu'un graphe n'est pas semi-hamiltonien, on recherche un chemin
    hamiltonien dans ce graphe.

    Pour rechercher un chemin hamiltonien dans un graphe, nous avons écrit un
    algorithme qui recherche parmi tout les chemins possibles. Sa complexité
    dans le pire des cas est donc très mauvaise: $O(n!)$. Comme on peut
    s'arrêter dès qu'on a trouvé un chemin sans devoir tester tout les autres
    chemins possibles, la complexité moyenne sera inférieure.

    Nous avons écrit une version améliorée de cet algorithme qui essaye
    d'éviter les culs de sac.

  \subsection{Algorithmes}
  \subsection{Tests}
    Nos algorithmes fonctionnent biens sur de petits graphes, mais ils sont
    beaucoup trop lents pour être utilisés sur de grands graphes.

\section{Problème du postier chinois}
  \subsection{Analyse mathématique}
    Le problème du postier chinois consiste à trouver le plus court chemin dans
    un graphe connexe passant au moins une fois par chaque arête, et revenant
    à son point de départ; ce problème est donc celui du facteur qui souhaite
    réaliser une tournée la plus rapide possible en passant par toutes les rues
    et retournant à la poste. 

    Ce problème peut être réduit à la recherche d'un couplage parfait de coût
    minimum, il peut donc être résolu en temps polynomial dans le cas général.

  \subsection{Méthode de résolution}
    Tout d'abord, si le graphe est eulérien, il suffit d'appliquer l'algorithme
    d'Euler pour avoir le chemin voulu.

    Sinon, la méthode de résolution consiste à transformer le graphe en graphe
    eulérien:
    \begin{itemize}
      \item on crée d'abord le graphe partiel contenant uniquement les sommets
        de degré impair;
      \item on transforme ensuite ce graphe en clique: pour chaque couple de
        sommets non reliés entre eux, on crée une arête les rejoignant,
        de poids égal au coût le plus faible possible pour rejoindre ces
        sommets dans le graphe inital (ceci se calcul facilement avec
        l'algorithme de Dijkstra);
      \item on cherche le couplage parfait de coût minimum: c'est à dire
        l'ensemble d'arêtes disjointes couvrant tous les sommets du graphe,
        dont la somme des poids doit est le plus faible possible.
        Pour cela, on peut utiliser des algorithmes comme celui d'Edmonds, mais
        dans notre implémentation, nous avons utilisé la bruteforce, par manque
        de temps;
      \item pour chaque arête de cet ensemble, on double le chemin le plus court
        reliant les nœuds reliés par cette arête dans le graphe initial;
      \item on obtient alors un graphe Eulérien sur lequel on applique
        l'algorithme d'Euler.
    \end{itemize}

\section{Problème voyageur de commerce} \label{sec:tsp}
  \subsection{Analyse mathématique}
    On s'intéresse ici à passer par tout les points d'un ensemble une et une
    seule fois en minimisant la distance totale du cycle. Ce problème est donc
    celui de la fraiseuse qui doit percer des trous dans une plaque le plus
    rapidement possible. Il pourrait aussi servir à résoudre le problème du car
    de touristes.

    On peut modéliser ce problème par un graphe complet, dont les arêtes ont un
    coup qui correspond à la distance entre chaque point, on cherche alors le
    cycle hamiltonien de coût minimal. On sait qu'un tel cycle existe car le
    graphe est complet.

    Cependant trouver un tel cycle est un problème NP-difficile, il n'existe
    donc pas d'algorithme efficace pour trouver ce cycle.

  \subsection{Méthode de résolution}
    Bien que la résolution exact de ce problème soit NP-complet, il existe des
    méthodes approchées de résolution.

    Un heuristique simple consiste à partir d'un sommet au hasard du graphe et
    d'aller au sommet le plus proche sur lequel on est pas encore passer (puis
    à retourner au sommet de départ pour boucler le cycle). Cet algorithme est
    en $O(n)$ et donc rapide. Mais il n'offre cependant aucune garantie de
    résultat, il existe même des graphes pour lesquels il donne le pire cycle.

    Il existe aussi des algorithmes non-constructifs comme le 2-opt, qui essaye
    d'améliorer un cycle donné en échangeant des sommets.

    %todo: fourmis ?

  \subsection{Algorithmes}
    \subsubsection{Plus proche voisin}
      \begin{lstlisting}
Entrée : g (Graphe complet)
Sortie : (coût, cycle) où cycle est un cycle hamiltonien construit selon la méthode du plus proche voisin et coût son coût associé sous forme de liste de points
coût = 0
cycle = ["un point de g au hasard"]

tant qu'il reste des points:
    # On ajoute au cycle le point suivant
    plus_proche = "point de g sur lequel on est pas encore passé le plus proche du dernier point du cycle"

    coût += "coût de plus_proche au dernier point du cycle"
    cycle = cycle :: plus_proche

# On ferme le cycle
coût += "coût du dernier au premier point de cycle"
cycle = cycle :: "premier point de chemin"

retourner (coût, cycle)
      \end{lstlisting}

    \subsubsection{$2$-opt}
      \begin{lstlisting}
Entrée : un cycle hamiltonien (liste de sommets) et son coût
Sortie : un cycle hamiltonien et son coût inférieur ou égal au coup d'entrée

pour chaque couple de points (a, b) dans le cycle:
    nouveau_coût = coût
                     - "coût de a à son successeur dans le cycle"
                     - "coût de b à son successeur dans le cycle"
                     + "coût de a à b"
                     + "coût du successeur de a et au successeur de b dans le cycle"

    si nouveau_coût < coût:
        coût = nouveau_coût
        cycle = cycle crée en échangeant a et b dans cycle

retourner (coût, cycle)
      \end{lstlisting}

  \subsection{Tests}
    Nous avons lancé cet algorithme sur plusieurs ``grands''
    graphes\footnote{Trouvés sur
      \url{http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/}.
    }, les résultats sont présentés dans la table~\ref{table:tsp}\footnote{N/A
    indique que l'algorithme est trop long ou cause une erreur à cause de la
    taille du graphe, pour chaque méthode de résolution sont données les
    longueurs des chemins trouvés et l'erreur relative avec le résultat
    optimum.}.

    \begin{table}[h]
      \makebox[\textwidth]{%
      \centering
      \begin{tabular}{| c | c | c | c | c | c |}
      \hline
        \brokencell{Fichier de\\test}
      & \brokencell{Résultat\\optimum}
      & \brokencell{Plus proche\\voisin}
      & \brokencell{Plus proche\\voisin + 2-opt}
      & \brokencell{Plus proche\\voisin amélioré}
      & \brokencell{Plus proche\\voisin amélioré\\+ 2-opt}\\
      \hline
      berlin52.tsp & $7542$  & $8981/19.1\%$ & $8060/6.7\%$ & $7972/5.7\%$ & $7810/3.6\%$ \\
      bier127.tsp & $118282$  & $137297/16.7\%$ & $125669/6.2\%$ & $127857/8.1\%$ & $122072/3.2\%$ \\
      d657.tsp & $48912$  & $62176/27.1\%$ & N/A & N/A & N/A \\
      u724.tsp     & $41910$ & $55344,32.1\%$ & N/A & N/A & N/A \\
      fl1577.tsp & $22249$  & N/A & N/A & N/A & N/A \\
      \hline  
      \end{tabular}
      }
      \caption{Résultats pour TSP}
      \label{table:tsp}
    \end{table}

    On remarque que bien qu'il ne fournisse aucune garantie, l'algorithme du
    plus proche voisin donne des résultats plutôt bons. % todo: mal dit

    L'application du 2-opt sur les résultats donnés par la méthode du plus
    proche voisin donne des résultats assez intéressants: ils sont très proches
    du résultat optimum. Malheuresement, cet algorithme est très coûteux en
    temps.

    L'algorithme du 2-opt a été appliqué en boucle tant qu'il améliorait le
    résultat pour \verb+berlin52.tsp+ et \verb+bier127.tsp+, mais pour le
    fichier \verb+d657.tsp+, il était beaucoup trop long pour pouvoir faire ça,
    cependant, après 50 itérations (4h de calcul), on obtient un chemin de coût
    $58754$, soit une erreur relative de $20.1\%$. L'algorithme est d'autant
    plus long que le cycle est déjà bon.

\section{Conclusion}
   Le python n'est évidemment pas adapté blabla

\section{Annexes}
  \lstlistoflistings
  %todo: listings de tout les codes
  \lstinputlisting[language=python, caption=Classes pour représenter un graphe]{graphs.py}
  \lstinputlisting[language=python, caption=Codes relatifs à la connexité]{connected.py}
  \lstinputlisting[language=python, caption=Codes relatifs au graphes eulériens]{eulerian.py}
  \lstinputlisting[language=python, caption=Codes relatifs au graphes hamiltonien]{hamiltonian.py}
  \lstinputlisting[language=python, caption=Codes relatifs postier chinois]{postier_chinois.py}
  \lstinputlisting[language=python, caption=Codes relatifs au TSP]{tsp.py}
  \lstinputlisting[language=python, caption=Tests]{tests.py}
\end{document}

